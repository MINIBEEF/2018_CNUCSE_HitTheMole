# 2018_CNUCSE_HitTheMole
This is my first java project
컴퓨터프로그래밍2 학기말 프로젝트 보고서
- 두더지잡기 게임 (3조) -

조원 : 강성엽, 김기훈, 박 민
제출 일자 : 2018년 12월 17일
담당 교수 : 김영국 교수님


- 목차 -
I) 프로젝트의 전반
    1) 게임 규칙
    2) 부수적인 기능

II) 역할 분담에 따른 프로그램 설명
    1) 강성엽 – Login
    2) 박민 – GUI 구성 및 게임 알고리즘
    3) 김기훈 – 서버와 랭킹

IV) 프로젝트 진행 방법



I-1) 게임 규칙
 우리가 구현한 ‘두더지잡기 게임’ 의 규칙은 다음과 같다.


1.. 게임의 제한시간은 20초이며, 이 제한시간 안에 가장 많은 점수를 획득한 플레이어가 우승하는 방식이다.

2.. 점수를 획득하는 방법은 다음과 같다.
    2-1.. 주기적으로 9개의 구멍에서 두더지가 머리를 내밀고, 다시 들어간다.
    2-2.. 두더지가 나온 상태에서 플레이어가 해당 구멍을 클릭하면 난이도에 따른 점수     를 획득한다. (Easy = 4점, Normal = 2점, Hard = 1점) 단, 머리를 내밀지 않은       두더지를 클릭하면 점수가 내려간다.
    2-3.. 20초의 제한시간이 끝나게 되면 게임은 종료되며, 게임에 플레이어가 획득한 점수를 랭킹으로 표시해준다.

3.. 두더지가 나오고 들어가는 속도는 게임 쓰레드로 정해져있고 난이도가 올라갈수록 딜레이가 짧아져 더 어려워진다.



I-2) 부수적인 기능
 우리 3조는 단순히 두더지 잡기 게임 자체만을 구현하는 것에 그치지 않고 이 프로젝트가 상업적으로 즉, 이 프로그램의 소비자가 있다고 가정했을 때 추가적으로 필요한 기능이 무엇이 있을지 고민한 결과 여러 가지 부수 기능을 추가하게 되었다.


 왼쪽은 우리가 구현한 기능을 모두 모아놓은 Title 프레임이다. 
 첫 번째로, Game Start는 게임을 하는 프레임으로 넘어갈 수 있는 버튼이다. 우리가 구현한 3가지 난이도(Easy, Normal, Hard)를 선택한 후 게임을 플레이할 수 있도록 서비스한다.
 두 번째로, How To Play?는 게임을 처음 접해보는 유저를 위해 간단하게 게임의 설명방법을 적어놓은 곳이다. 이곳의 텍스트는 java swing의 JLabel을 통해 구현하였다.
 세 번째로 Ranking은 자신이 지금까지 플레이를 하면서 얻은 스코어 전적을 확인할 수 있는 프레임이다. 게임 플레이가 끝나게 되면 입출력 스트림을 통해 메모장에 산정된 스코어가 저장되고, 플레이어는 이 스코어를 Ranking 프레임을 통해 다시 한번 확인할 수 있게 해주는 기능이다.

III) 역할에 분담에 따른 프로그램 설명
 프로젝트를 진행하면서 역할 분담의 필요성을 느끼게 되었고, 개발 초기에 개별 조원들이 선호하거나 우수한 능력을 보이는 분야를 찾아 역할을 나누고 효율적으로 과제를 진행하려 노력하였다. 텀 프로젝트 기간 동안 주어진 역할을 충실히 실행하되, 다른 조원이 맡은 파트와 잘 융합되도록 주기적인 만남과 github의 적극 활용으로 조직성을 높였다.

III-1) 강성엽 – Login

배치관리자는 절대 배치 관리자로 정하고 배치를 했다. 이 로그인&회원가입은 대체적으로 스트림을 사용하여 로그인을 구현했다. 먼저 Login클래스에서 로그인 버튼은 txt파일에서 각각 아이디와 비밀번호가 있는 지 없는 지 확인을 하고 있으면 로그인이 성공하고 없으면 로그인이 실패한다. SignUp클래스에선 중복확인은 위와 똑같이 txt파일에서 확인을 하고 회원등록 버튼은 아이디와 비밀번호를 txt파일에 저장을 하는데 이 과정에서 아직 2명이상의 회원이 등록되지 않고 2명을 등록하려고 하면 파일 또한 이상하게 변하여 txt에 아이디와 비밀번호가 있어도 로그인이 실패한다고 뜬다. 아직까지 이 오류는 어떻게 고쳐야 할지 모르겠다.

직접 두더지 이미지를 그렸다. 이미지를 버튼에 넣는 방법은 수업 이론에서 나온 것을 토대로 사용했다.

III-2) 박민 - GUI 구성 및 게임 알고리즘
 GUI의 전반적인 부분을 구성하면서 Frame이 변하는 지점을 기준으로 코드를 작성해 나가면 다른 조원들이 읽기에 가독성과 코드 간의 구조, 긴밀성이 탄탄할 것으로 예상해 다음과 같이 프레임을 구성하였다. 이 작업의 특성상 다른 조원들의 코드를 받아 전체적인 틀에 적용시켜야 하므로 코드의 가독성을 위해 꼼꼼한 주석작성과 변수명 선정에 공을 들였다.


1. Login – 강성엽 조원

2. Title Frame
    2-1. Game Start Frame (게임 난이도를 설정할 수 있는 Frame)
        2-2-1. Play Frame (게임 난이도를 설정 후 실질적인 두더지 잡기 시작)
    
    2-2. HowToPlay? Frame (게임 방법을 설명하는 Frame)
    
    2-3. Ranking Frame – 김기훈 조원
        2-3-1. Easy Ranking
        2-3-2. Normal Ranking
        2-3-3. Hard Ranking



 각 프레임들은 CardLayout으로 작성하지 않고, 프레임마다 class를 나누어 프레임이 바뀔 때에는 dispose() 메서드를 호출 후 => 넘어가야 할 프레임의 생성자 호출(new Frame())을 통해 구현하였다. 왼쪽의 그림은 참고 사진이다.





<그림 – Frame별로 분류된 class들>

또한, 게임 알고리즘을 짜는 과정에서는 우리가 수업시간에 배운 쓰레드를 적용시키고자 노력했고, 만족스러운 결과를 얻어냈다.


두더지 게임에 쓰인 쓰레드는 다음과 같다.


쓰레드 1 (Game_Controller_Thread) - 0~8까지 난수 발생, 해당 순번에 해당하는 JButton(게임 상에서는 두더지)의 Icon을 두더지가 나온 상태로 변환.

쓰레드 2 (Game_RealTime_Controller_Thread) - 실시간으로 갱신되는 부분을 관장, 스코어와 진행 시간을 게임 프레임상에 주기적으로 갱신해주고, 제한시간인 20초가 초과하면 게임을 종료, 스코어를 저장하는 역할을 하는 쓰레드.
 


 Game_Controller_Thread 이다. run에서 랜덤한 위치에 두더지 아이콘을 두더지가 나온 상태(Digda_Alive)와 두더지가 들어간 상태(Digda_Hole)로 계속해서 변환해주는 모습을 볼 수 있다. 또한 쓰레드는 Runnable 인터페이스로 구현하는 것의 이점을 수업시간에 배웠으므로 이를 적극 활용하여 implements 해주었다.




Game_RealTime_Controller_Thread의 모습이다.

실시간으로 스코어 갱신과 시간 갱신을 하는 것을 볼 수 있으며, 타임아웃도 구현되어있다.




III-3) 김기훈 – 서버와 랭킹

 서버와 클라이언트를 소켓으로 연결하였다. 파일 스트림을 통해 서버 측에 저장되어있는 ranking_s.txt파일의 데이터를 읽은 후 이를 소켓에 연결된 클라이언트에 전송하고, 클라이언트는 이를 읽어들여 다시 파일 스트림으로 ranking_c.txt파일에 저장하는 코드이다. 
서버에서 클라이언트로의 데이터 전송은 정상적으로 진행되었지만 클라이언트에서 스코어를 서버로 전송하는 메소드를 추가하자 오류가 발생하여 구현하지 못하였고, 난이도별로 랭킹을 읽어오는 기능을 구현하였지만 알 수 없는 이유로 작동하지 않아 서버-클라이언트 구현에 실패하였다. 멀티스레딩을 정확히 알고 이를 바탕으로 구현하였다면 구현이 가능했을 것이라 생각한다. 또한 서버를 반복 실행할 때 소켓이 사용 중인 포트에 접근한다는 오류가 발생한 것에 있어 접속하기 전 사용하고 있는 포트라면 다른 포트를 찾아 접속하는 코드 추가가 필요할 것 같다.

랭킹부분은 각 easy, normal, hard난이도에 다라 버튼이 존재하고 이 버튼을 누르게 되면 각 난이도 별 랭킹 파일을 읽어와 ArrayList에 저장한다. 그리고 이를 배열에 저장하고 랭킹을 프레임에 출력하는 코드이다. 랭킹 클래스에서는 ArrayList에 저장한 뒤 이를 정렬 후 배열에 저장하고, 이를 랭킹으로 출력하는 코드를 구현하였지만 정렬된 결과가 정상적으로 저장되기는 하였으나 이를 프레임에 출력하는 과정에서 오류가 발생하여 최종적으로 정렬된 랭킹 구현에는 실패하였고 게임의 순서대로 랭킹을 표시할 수는 있었다. 배열과 ArrayList에 데이터를 저장할 때 자료형에 신경을 좀 더 썼더라면 정상적으로 표시되었을 것이라 생각한다. 
최종적으로 보완해야 할 점을 정리하면 서버-클라이언트 간의 통신에 있어 한 가지 작업만을 수행할 수 있었던 것을 해결해야 하고 사용 중인 포트를 피하는 것이 필요하다. 랭킹에서는 ArrayList와 배열에서 저장과 출력 부분에서의 자료형에 신경쓰는 것이 필요하다.

IV) 프로젝트 진행방법
 합동 프로젝트에서 가장 핵심이 되는 것은 보안성이나 알고리즘과 같이 기술적인 부분이 아니라 팀원들과의 원활한 소통과 협력이라고 생각했기 때문에 본 프로젝트를 진행한 3조는 2학기 내내 카카오톡 단체 채팅방과 github를 통해 코드를 공유하고 의논하며 오프라인으로 만나 밤샘 작업을 하기도 했다.


  정말 기본적인 사항이지만 우리 나름의 개발 규칙을 정하고, guthub의 기능인 Wiki를 이용해 규칙과 우리가 생각하는 개발 방향, 역할 분담 등을 기술해 놓았다. 덕분에 처음에 생각한 프로젝트의  완성본과 실제 완성본의 싱크가 높았고, 의사소통과 코드의 퀄리티에서 우수한 결과를 얻을 수 있었다.






